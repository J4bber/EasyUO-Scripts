;=================================================================
; Script Name: TrailMyx's Drag(and Drop) Queen
; Author: TrailMyx
; Version: 0.10
; Shard OSI / FS: OSI / FS OK
; Revision Date: 9/29/2007
; Purpose: Simplify the act of moving items from container to container
; Globals:
; Special Thanks:
;   Cerveza the UO master!
;
;=================================================================
; Disclaimer:  By running this script, you are accepting the contents of this licence agreement.
; This script is only authorized to be distributed on www.scriptuo.com.  If you purchase this script,
; acquire it from another website, it is not considered an authorized copy and should be deleted
; immediately.
; You hold the author, TrailMyx, and the distribution site www.scriptuo.com not liable for any loss of
; items, accounts, monitary or time losses associated with the use of this script.  Furthermore, you promise
; not to distribute or sell this script to anyone without the express permission of the author, Trailmyx.
; Violation of the contents of this agreement will result in one of the following: litigation, www.scriptuo.com
; account termination, discimination of bad karma for your next life, and most definitely causing a black mark
; placed on your soul.
;
; I worked very hard to bring this script to you, so please use it responisibily and
; respectfully.  If you have any questions, please reach me at trailmyx@yahoo.com.
; (c) 2007 TrailMyx, All rights reserved.
;
; Thanks to bug testers: Bookwyrm, The Ghost, Crisis
;===================================================================
set #LPC 100
gosub showEUOMenu1
gosub TM_CreateList List KeepList 0 4 205 93 White WindowText %font_arial 8
gosub TM_CreateList List IgnoreList 0 100 205 93 White WindowText %font_arial 8
gosub TM_ReDrawList KeepList ; redraw list
gosub TM_ReDrawList IgnoreList ; redraw list
set %type N/A
set %ignore_list
set %sample_contid N/A
set %first_moved
set %keep_items expert_
menu set EUOEditIgnore %keep_items
gosub TM_SplitString %keep_items _
set %string_count #RESULT
gosub TM_AdvJournalSync drag
set #MENUBUTTON N/A
set %enabled #TRUE
set %use_ignore_text #TRUE
;-------------------------------------------------------------------------------
repeat
  menu get EUOCheckUseText
  if #MENURES = #FALSE && %use_ignore_text = #TRUE
    set %use_ignore_text #FALSE
  if #MENURES = #TRUE && %use_ignore_text = #FALSE
    set %use_ignore_text #TRUE
  if #MENUBUTTON = EUOButtonEnable
  {
    set #MENUBUTTON N/A
    if %enabled = #FALSE
    {
      menu Font BGColor BtnFace
      menu delete EUOButtonEnable
      menu Button EUOButtonEnable 4 244 67 33 Disable
      menu set EUOStatus Ready to drag.
      set %enabled #TRUE
    }
    else
    {
      menu Font BGColor BtnFace
      menu delete EUOButtonEnable
      menu Button EUOButtonEnable 4 244 67 33 Enable
      menu set EUOStatus Paused..
      set %enabled #FALSE
    }
  }
  if #MENUBUTTON = EUOButtonDelete2
  {
    set #MENUBUTTON N/A
    menu get KeepList
    if #MENURES > 0
      gosub TM_DeleteIndexedItemInList KeepList #MENURES #TRUE
  }
  if #MENUBUTTON = EUOButtonClear2
  {
    set #MENUBUTTON N/A
    display yesno Are you sure you want to clear the list?
    if #DISPRES = yes
    {
      gosub TM_DeleteAllItemsInList KeepList #TRUE 
    }
  }
  if #MENUBUTTON = EUOButtonDelete1
  {
    set #MENUBUTTON N/A
    menu get IgnoreList
    if #MENURES > 0
      gosub TM_DeleteIndexedItemInList IgnoreList #MENURES #TRUE
  }
  if #MENUBUTTON = EUOButtonClear1
  {
    set #MENUBUTTON N/A
    display yesno Are you sure you want to clear the list?
    if #DISPRES = yes
    {
      gosub TM_DeleteAllItemsInList IgnoreList #TRUE 
    }
  }
  if %enabled = #TRUE
  {
    menu get EUOEditIgnore
    gosub TM_DragCheck
  }
until #FALSE
;-------------------------------------------------------------------------------
sub TM_DragCheck
  repeat
  until #CONTNAME <> stack_gump
  if #CONTNAME = drag_gump && %sample_contid <> N/A
  {
    set %type #LLIFTEDTYPE
    set %findid #LLIFTEDID
    event property #LLIFTEDID
    set %property #PROPERTY
    gosub TM_GenerateTagList IgnoreList
    if %type notin #RESULT
    {
      repeat
        set %x #CURSORX
        set %y #CURSORY
      until #CONTNAME <> drag_gump
      set %dest_cont #CONTID
      if %dest_cont = N/A || %last_cont = N/A
        continue
      gosub TM_GenerateTagList KeepList
      if %type notin #RESULT
      {
        event property %findid
        gosub TM_SplitString #PROPERTY $
        gosub TM_GetIndex 0
        display yesno Do you want me to move the rest of these?
        if #DISPRES = no
        {
          gosub TM_AddToList IgnoreList #RESULT %type
          return
        }
        gosub TM_AddToList KeepList #RESULT %type
      }  
      wait 10
      gosub TM_SplitString #MENURES _ ; get ignore strings and count them
      set %string_count #RESULT
      gosub DragAll %type %last_cont %dest_cont
    }
  }
  set %temp_contid #CONTID
  set %temp_name #CONTNAME
  if %temp_contid <> N/A
  {
    set %last_name %sample_name
    set %last_cont %sample_contid
    set %sample_name %temp_name
    set %sample_contid %temp_contid
  }
return
;-----------------------------------------------------------------
sub TM_GenerateTagList
  namespace push
  namespace local TM_window_list_ , %1
  set !listname %1
  set !idx 0
  set !rval
  while !idx < !list_ptr
  {
    set !temp !tag . !idx
    set !rval !rval , !temp , _
    set !idx !idx + 1
  }
  set #RESULT !rval
  namespace pop
return #RESULT
;-------------------------------------------------------------------------------
sub TM_SplitString
  namespace push
  namespace local PS
  namespace clear
  set !string %1
  set !delimiter %2
  set !cnt 0
  set !ptr 1
  set !start 1
  set !end 1
  str pos !string !delimiter !ptr
  repeat
    if #STRRES = 0
      break
    set !len #STRRES - !start
    str mid !string !start !len
    set !array . !cnt #STRRES
    set !start !start + !len + 1
    set !cnt !cnt + 1
    set !ptr !ptr + 1
    str pos !string !delimiter !ptr
  until #STRRES = 0
  set #RESULT !cnt
  namespace pop
return #RESULT
;-------------------------------------------------------------------------------
sub TM_GetIndex
  namespace push
  namespace local PS
  set !index %1
  set #RESULT !array . !index
  namespace pop
return #RESULT
;-------------------------------------------------------------------------------
sub DragAll
  namespace push
  namespace local DA
  set !item %1
  set !source %2
  set !dest %3
  finditem !item C_ , !source

  set !drag_cnt 0
  set !ignore_cnt 0
  if #FINDCNT > 0
  {
    for #FINDINDEX 1 #FINDCNT
    {    
      if #MENUBUTTON = EUOButtonEnable
        break
      if %string_count > 0 && %use_ignore_text = #TRUE
      {
        event property #FINDID
        for !index 1 %string_count
        {
          set !temp !index - 1
          gosub TM_GetIndex !temp
          if #RESULT NOTIN #PROPERTY
          {
            if %property = #PROPERTY
            {
              set !drag_cnt !drag_cnt + 1
              menu set EUOStatus dragging , #SPC , !drag_cnt , #SPC , of , #SPC , #FINDCNT
              gosub TM_AdvancedDragDrop
            }
          }
          else
          {
            set !ignore_cnt !ignore_cnt + 1
            menu set EUOStatus Ignoring , #SPC , !ignore_cnt , #SPC , of , #SPC , #FINDCNT         
          }
        }
      } 
      else 
      {
        if %property = #PROPERTY
        {
          set !drag_cnt !drag_cnt + 1
          menu set EUOStatus dragging , #SPC , !drag_cnt , #SPC , of , #SPC , #FINDCNT
          gosub TM_AdvancedDragDrop
        }
      }
      menu get EUOCheckMax
      if #MENURES = #TRUE
      {
        menu get EUOEditMax
        if !drag_cnt >= #MENURES
          break
      }
    }
    menu set EUOStatus Drag complete. , #SPC , !ignore_cnt , #SPC , ignored.
  }
  else
  {
    menu set EUOStatus Nothing to drag.
  }
  namespace pop
return
;-------------------------------------------------------------------------------
sub TM_AdvancedDragDrop
  menu get EUOCheckClosedContainer
  if #MENURES = #FALSE
  {
    exevent drag #FINDID #FINDSTACK
    exevent dropc !dest
    wait 19    
  }
  else
  {
    event drag #FINDID
    gosub GumpWait stack_gump drag_gump
    if #CONTNAME = stack_gump
    {
      msg #FINDSTACK , $
      gosub GumpWait drag_gump drag_gump
    }
    click %x %y mp
    wait 5
  }
return
;-------------------------------------------------------------------------------
sub GumpWait
  wait 5
  set %timedelay #SCNT
loopwait1:
  if #CONTNAME = %1 || #CONTNAME = %2
    return
  if #SCNT > %timedelay + 7
    return
  goto loopwait1
return
;-------------------------------------------------------------------------------
; %1 - Journal Name
; %2 - #LPC setting (optional)
; Brings !_jindex up to the most recent #journal entry
sub TM_AdvJournalSync
  namespace push
  namespace local TM_AdvJS_ , %1
  set !_jindex #jindex + 1
  if %0 > 1
    set !lpc_set %2
  namespace pop
  set !TM_FunctionCalled #TRUE
return
;-------------------------------------------------------------------------------
; %1 - Journal Name
; %2 - NONE, ADVANCE , ( _VALID ) - advances jindex pointer, anything else
; %3, %4, %5, etc strings to match
; returns #TRUE for match, #FALSE for no match
;  Will not advance !_jindex pointer to allow for scanning journal history for more than one search.
;  Also searches for : , #SPC in journal entry to be sure someone isn't spamming the text
;  About %2 arguments:
;    NONE: defaults to basic journal scan (no SPAM checking, no #jindex pointer copy advancing)
;    ADVANCE: no spam checking, advances #jindex copy
;    VALID: invokes SPAM filtering, no advance of #jindex copy
;    VALID_ADVANCE, VALIDADVANCE, ADVANCE_VALID, etc.: invokes SPAM filtering, advances of #jindex copy
sub TM_AdvJournalScan
  namespace push
  namespace local TM_AdvJS_ , %1
  set !args %2
  set !temp_lpc #LPC
  if !lpc_set = N/A
    set #LPC 1000
  else
    set #LPC !lpc_set
  set !num_args %0
  set !first_arg 3
  set !sampled_jindex #JINDEX
  if !_jindex = N/A
    set !_jindex !sampled_jindex
  if !charname = N/A
  {
    set !charname #CHARNAME
    AdvJournalScan_loop1:
      str pos !charname #SPC
      if #STRRES <> 0
      {
        set !val #STRRES - 1
        str left !charname !val
        set !left #STRRES
        set !val !val + 1
        str del !charname 1 !val
        set !charname !left , _ , #STRRES
        goto AdvJournalScan_loop1
      }
  }
  set !index !first_arg
  repeat
    set !temp_jindex !_jindex
    set !text % . !index
    while !temp_jindex <= !sampled_jindex
    {
      scanjournal !temp_jindex
      str pos #JOURNAL !charname 1
      set !namepos #STRRES
      str count #JOURNAL !charname
      set !namecnt #STRRES
      str pos #JOURNAL :_ 1
      set !smcpos #STRRES
      str pos #JOURNAL !text 1
      set !textpos #STRRES
      if !textpos < !smcpos && !smcpos <> 0 || !smcpos = 1 || :_ notin #JOURNAL || VALID notin !args
        set !pass #TRUE
      else
        set !pass #FALSE
      if ( !text in #journal && ( ( !namepos = 1 && !namecnt <= 1 ) || !pass ) )
      {
        set !temp_jindex !temp_jindex + 1
        if ADVANCE in !args
          set !_jindex !temp_jindex
        set #LPC !temp_lpc
        namespace pop
        set !TM_FunctionCalled #TRUE
        return #TRUE
      }
      set !temp_jindex !temp_jindex + 1
    }
    set !index !index + 1
  until !index - !first_arg > !num_args - !first_arg
  set %10 !sampled_jindex - !_jindex
  set %10 %1 , _ , %10 ; for debugging purposes
  set #LPC !temp_lpc
  namespace pop
  set !TM_FunctionCalled #TRUE
return #FALSE
;-----------------------------------------------------------------
sub TM_LoadList
  namespace push
  namespace local LLFF
  set !name %1
  gosub TM_NGFS_InitializeScript !name
  gosub TM_NGFS_LoadVariables !name
  namespace pop
  set !TM_FunctionCalled #TRUE
return
;-----------------------------------------------------------------
sub TM_SaveList
  namespace push
  namespace local TM_window_list_ , %1
  set !listname %1
  gosub TM_NGFS_InitializeScript !listname
  gosub TM_NGFS_RegisterVariables !listname local TM_window_list_ , !listname listtype
  gosub TM_NGFS_RegisterVariables !listname local TM_window_list_ , !listname listname
  gosub TM_NGFS_RegisterVariables !listname local TM_window_list_ , !listname x1
  gosub TM_NGFS_RegisterVariables !listname local TM_window_list_ , !listname y1
  gosub TM_NGFS_RegisterVariables !listname local TM_window_list_ , !listname x2
  gosub TM_NGFS_RegisterVariables !listname local TM_window_list_ , !listname y2
  gosub TM_NGFS_RegisterVariables !listname local TM_window_list_ , !listname bgcolor
  gosub TM_NGFS_RegisterVariables !listname local TM_window_list_ , !listname txtcolor
  gosub TM_NGFS_RegisterVariables !listname local TM_window_list_ , !listname font
  gosub TM_NGFS_RegisterVariables !listname local TM_window_list_ , !listname fontsize
  gosub TM_NGFS_RegisterVariables !listname local TM_window_list_ , !listname fontstyle
  gosub TM_NGFS_RegisterVariables !listname local TM_window_list_ , !listname draw
  gosub TM_NGFS_RegisterVariables !listname local TM_window_list_ , !listname list_ptr

	for !j 0 !list_ptr
	{
	  gosub TM_NGFS_RegisterVariables !listname local TM_window_list_ , !listname list , !j
	  gosub TM_NGFS_RegisterVariables !listname local TM_window_list_ , !listname tag , !j
	}
	gosub TM_NGFS_SaveVariables !listname
	set #RESULT !listname
  namespace pop
  set !TM_FunctionCalled #TRUE
return #RESULT
;-----------------------------------------------------------------
sub TM_CreateList
  namespace push
  namespace local TM_window_list_ , %2
  namespace clear
  set !listtype %1
  set !listname %2
  set !x1 %3
  set !y1 %4
  set !x2 %5
  set !y2 %6
  set !bgcolor %7
  set !txtcolor %8
  set !font %9
  set !fontsize %10
  if %0 >= 11
    set !fontstyle %11
  else
    set !fontstyle N/A
  set !draw #TRUE

  if NODRAW in !listtype
    set !draw #FALSE

  if List in !listtype
    set !listtype List

  if Combo in !listtype
    set !listtype Combo

  if !draw = #TRUE
    gosub TM_DrawList !listname
  set !list_ptr 0
  namespace pop
  set !TM_FunctionCalled #TRUE
return
;-----------------------------------------------------------------
sub TM_DrawList
  namespace push
  namespace local TM_window_list_ , %1
  set !temp2_LPC #LPC
  set #LPC 1000
  set !listname %1
  menu Font BGColor !bgcolor
  menu Font Color !txtcolor
  menu Font Size !fontsize
  menu Font Name !font
  if !fontstyle = N/A
    menu Font Style
  else
    menu Font Style !fontstyle
  menu !listtype create !listname !x1 !y1 !x2 !y2
  set !end !list_ptr - 1
  if !end >= 0
  {
    for !i 0 !end
      menu !listtype add !listname !list . !i
  }
  set #LPC !temp2_LPC
  namespace pop
  set !TM_FunctionCalled #TRUE
return
;-----------------------------------------------------------------
sub TM_HideList
  namespace push
  namespace local TM_window_list_ , %1
  menu delete %1
  namespace pop
  set !TM_FunctionCalled #TRUE
return
;-----------------------------------------------------------------
sub TM_ReDrawList
  namespace push
  namespace local TM_window_list_ , %1
  menu delete %1
  gosub TM_DrawList %1
  namespace pop
  set !TM_FunctionCalled #TRUE
return
;-----------------------------------------------------------------
sub TM_AddToList
  namespace push
  namespace local TM_window_list_ , %1
  set !listname %1
  set !item %2
  set !tag %3
  set !list . !list_ptr !item
  set !tag . !list_ptr !tag
  set !list_ptr !list_ptr + 1
  set #RESULT !list_ptr
  menu !listtype add !listname !item
  namespace pop
  set !TM_FunctionCalled #TRUE
return #RESULT
;-----------------------------------------------------------------
sub TM_GetListSize
  namespace push
  namespace local TM_window_list_ , %1
  set #RESULT !list_ptr
  namespace pop
  set !TM_FunctionCalled #TRUE
return #RESULT
;-----------------------------------------------------------------
sub TM_DeleteAllItemsInList
  namespace push
  namespace local TM_window_list_ , %1
  set !temp_LPC #LPC
  set #LPC 1000
  set !listname %1
  set !redraw %2
  if !list_ptr >= 0
  {
    for !i 0 !list_ptr
    {
      set !list . !i N/A
      set !tag . !i N/A
    }
    set !list_ptr 0
    if !redraw = #TRUE
      gosub TM_ReDrawList !listname
  }
  set #LPC !temp_LPC
  namespace pop
  set !TM_FunctionCalled #TRUE
return #RESULT
;-----------------------------------------------------------------
sub TM_CopyAllItemsInList
  namespace push
  namespace local TM_window_list_ , %1
  set !temp_LPC #LPC
  set #LPC 1000
  set !listname1 %1
  set !listname2 %2
  set !append %3
  set !redraw %4
  if !append <> #TRUE
    gosub TM_DeleteAllItemsInList !listname2
  if !list_ptr > 0
  {
    set !end !list_ptr - 1
    for !i 0 !end
      gosub TM_AddToList !listname2 !list . !i !tag . !i
    if !redraw = #TRUE
      gosub TM_ReDrawList !listname2
  }
  set #LPC !temp_LPC
  namespace pop
  set !TM_FunctionCalled #TRUE
return #RESULT
;-----------------------------------------------------------------
sub TM_DeleteIndexedItemInList
  namespace push
  namespace local TM_window_list_ , %1
  set !temp_LPC #LPC
  set #LPC 1000
  set !listname %1
  set !index %2 - 1
  set !redraw %3
  if !index >= 0 && !index <= !list_ptr
  {
    menu set EUOEditBBC !list . !index
    for !i !index !list_ptr
    {
      set !next !i + 1
      set !list . !i !list . !next
      set !tag . !i !tag . !next
    }
    set !list . !next N/A
    set !tag . !next N/A
    set !list_ptr !list_ptr - 1
    if !redraw = #TRUE
      gosub TM_ReDrawList !listname
  }
  set #LPC !temp_LPC
  namespace pop
  set !TM_FunctionCalled #TRUE
return #RESULT
;-----------------------------------------------------------------
sub TM_DeleteExactItemsInList
  namespace push
  namespace local TM_window_list_ , %1
  set !temp_LPC #LPC
  set #LPC 1000
  set !listname %1
  set !item %2
  set !deleteall %3
  set !redraw %4
  set !count 0
  for !j 0 !list_ptr
  {
    if !list . !j = !item
    {
      set !count !count + 1
      for !i !j !list_ptr
      {
        set !next !i + 1
        set !list . !i !list . !next
        set !tag . !i !tag . !next
      }
      set !j !j - 1
      set !list_ptr !list_ptr - 1
      if !deleteall = #FALSE
        break
    }
  }
  if !redraw = #TRUE
    gosub TM_ReDrawList !listname
  set #RESULT !count
  set #LPC !temp_LPC
  namespace pop
  set !TM_FunctionCalled #TRUE
return #RESULT
;-----------------------------------------------------------------
sub TM_DeleteExactTagInList
  namespace push
  namespace local TM_window_list_ , %1
  set !temp_LPC #LPC
  set #LPC 1000
  set !listname %1
  set !tag %2
  set !deleteall %3
  set !redraw %4
  set !count 0
  for !j 0 !list_ptr
  {
    if !tag . !j = !tag
    {
      set !count !count + 1
      for !i !j !list_ptr
      {
        set !next !i + 1
        set !list . !i !list . !next
        set !tag . !i !tag . !next
      }
      set !j !j - 1
      set !list_ptr !list_ptr - 1
      if !deleteall = #FALSE
        break
    }
  }
  if !redraw = #TRUE
    gosub TM_ReDrawList !listname
  set #RESULT !count
  set #LPC !temp_LPC
  namespace pop
  set !TM_FunctionCalled #TRUE
return #RESULT
;-----------------------------------------------------------------
sub TM_DeleteItemsInList
  namespace push
  namespace local TM_window_list_ , %1
  set !temp_LPC #LPC
  set #LPC 1000
  set !listname %1
  set !item %2
  set !deleteall %3
  set !redraw %4
  set !count 0
  for !j 0 !list_ptr
  {
    if !item in !list . !j
    {
      set !count !count + 1
      for !i !j !list_ptr
      {
        set !next !i + 1
        set !list . !i !list . !next
        set !tag . !i !tag . !next
      }
      set !j !j - 1
      set !list_ptr !list_ptr - 1
      if !deleteall = #FALSE
        break
    }
  }
  if !redraw = #TRUE
    gosub TM_ReDrawList !listname
  set #RESULT !count
  set #LPC !temp_LPC
  namespace pop
  set !TM_FunctionCalled #TRUE
return #RESULT
;-----------------------------------------------------------------
sub TM_DeleteTagsInList
  namespace push
  namespace local TM_window_list_ , %1
  set !temp_LPC #LPC
  set #LPC 1000
  set !listname %1
  set !tag %2
  set !deleteall %3
  set !redraw %4
  set !count 0
  for !j 0 !list_ptr
  {
    if !tag in !tag . !j
    {
      set !count !count + 1
      for !i !j !list_ptr
      {
        set !next !i + 1
        set !list . !i !list . !next
        set !tag . !i !tag . !next
      }
      set !j !j - 1
      set !list_ptr !list_ptr - 1
      if !deleteall = #FALSE
        break
    }
  }
  if !redraw = #TRUE
    gosub TM_ReDrawList !listname
  set #RESULT !count
  set #LPC !temp_LPC
  namespace pop
  set !TM_FunctionCalled #TRUE
return #RESULT
;-----------------------------------------------------------------
sub TM_SearchForExactItemInList
  namespace push
  namespace local TM_window_list_ , %1
  set !temp_LPC #LPC
  set #LPC 1000
  set !listname %1
  set !item %2
  set !highlight %3
  for !i 0 !list_ptr
  {
    if !list . !i = !item
    {
      set #RESULT !i + 1
      if !highlight = #TRUE
        menu !listtype select !listname #RESULT
      namespace pop
      return #RESULT
    }
  }
  set #LPC !temp_LPC
  namespace pop
  set !TM_FunctionCalled #TRUE
return #FALSE
;-----------------------------------------------------------------
sub TM_SearchForExactTagInList
  namespace push
  namespace local TM_window_list_ , %1
  set !temp_LPC #LPC
  set #LPC 1000
  set !listname %1
  set !tag %2
  set !highlight %3
  for !i 0 !list_ptr
  {
    if !tag . !i = !tag
    {
      set #RESULT !i + 1
      if !highlight = #TRUE
        menu !listtype select !listname #RESULT
      namespace pop
      return #RESULT
    }
  }
  set #LPC !temp_LPC
  namespace pop
  set !TM_FunctionCalled #TRUE
return #FALSE
;-----------------------------------------------------------------
sub TM_SearchForItemInList
  namespace push
  namespace local TM_window_list_ , %1
  set !temp_LPC #LPC
  set #LPC 1000
  set !listname %1
  set !item %2
  set !highlight %3
  for !i 0 !list_ptr
  {
    if !item in !list . !i
    {
      set #RESULT !i + 1
      if !highlight = #TRUE
        menu !listtype select !listname #RESULT
      namespace pop
      return #RESULT
    }
  }
  set #LPC !temp_LPC
  namespace pop
  set !TM_FunctionCalled #TRUE
return #FALSE
;-----------------------------------------------------------------
sub TM_SearchForTagInList
  namespace push
  namespace local TM_window_list_ , %1
  set !temp_LPC #LPC
  set #LPC 1000
  set !listname %1
  set !tag %2
  set !highlight %3
  for !i 0 !list_ptr
  {
    if !tag in !tag . !i
    {
      set #RESULT !i + 1
      if !highlight = #TRUE
        menu !listtype select !listname #RESULT
      set #LPC !temp_LPC
      namespace pop
      return #RESULT
    }
  }
  set #LPC !temp_LPC
  namespace pop
  set !TM_FunctionCalled #TRUE
return #FALSE
;-----------------------------------------------------------------
sub TM_CountExactItemsInList
  namespace push
  namespace local TM_window_list_ , %1
  set !temp_LPC #LPC
  set #LPC 1000
  set !listname %1
  set !item %2
  set !count 0
  for !i 0 !list_ptr
  {
    if !list . !i = !item
      set !count !count + 1
  }
  set #RESULT !count
  set #LPC !temp_LPC
  namespace pop
  set !TM_FunctionCalled #TRUE
return #RESULT
;-----------------------------------------------------------------
sub TM_CountExactTagsInList
  namespace push
  namespace local TM_window_list_ , %1
  set !temp_LPC #LPC
  set #LPC 1000
  set !listname %1
  set !tag %2
  set !count 0
  for !i 0 !list_ptr
  {
    if !tag . !i = !tag
      set !count !count + 1
  }
  set #RESULT !count
  set #LPC !temp_LPC
  namespace pop
  set !TM_FunctionCalled #TRUE
return #RESULT
;-----------------------------------------------------------------
sub TM_CountItemsInList
  namespace push
  namespace local TM_window_list_ , %1
  set !temp_LPC #LPC
  set #LPC 1000
  set !listname %1
  set !item %2
  set !count 0
  for !i 0 !list_ptr
  {
    if !item in !list . !i
      set !count !count + 1
  }
  set #RESULT !count
  set #LPC !temp_LPC
  namespace pop
  set !TM_FunctionCalled #TRUE
return #RESULT
;-----------------------------------------------------------------
sub TM_CountTagsInList
  namespace push
  namespace local TM_window_list_ , %1
  set !temp_LPC #LPC
  set #LPC 1000
  set !listname %1
  set !tag %2
  set !count 0
  for !i 0 !list_ptr
  {
    if !tag in !tag . !i
      set !count !count + 1
  }
  set #RESULT !count
  set #LPC !temp_LPC
  namespace pop
  set !TM_FunctionCalled #TRUE
return #RESULT
;-----------------------------------------------------------------
sub TM_GetIndexedItem
  namespace push
  namespace local TM_window_list_ , %1
  set !temp_LPC #LPC
  set #LPC 1000
  set !listname %1
  set !index %2
  gosub TM_GetListSize
  if !index >= 0 && !index < #RESULT
    set #RESULT !list . !index
  else
    set #RESULT #TRUE
  set #LPC !temp_LPC
  namespace pop
  set !TM_FunctionCalled #TRUE
return #RESULT
;-----------------------------------------------------------------
sub TM_UpdateIndexedItem
  namespace push
  namespace local TM_window_list_ , %1
  set !temp_LPC #LPC
  set #LPC 1000
  set !listname %1
  set !index %2
  set !item %3
  set !tag %4
  gosub TM_GetListSize
  if !index >= 0 && !index < #RESULT
  {
    set !list . !index !item
    set !tag . !index !tag
  }
  set #RESULT #TRUE
  set #LPC !temp_LPC
  namespace pop
  set !TM_FunctionCalled #TRUE
return #RESULT
;-----------------------------------------------------------------
sub TM_GetIndexedTag
  namespace push
  namespace local TM_window_list_ , %1
  set !temp_LPC #LPC
  set #LPC 1000
  set !listname %1
  set !index %2
  gosub TM_GetListSize
  if !index >= 0 && !index < #RESULT
    set #RESULT !tag . !index
  else
    set #RESULT #TRUE
  set #LPC !temp_LPC
  namespace pop
  set !TM_FunctionCalled #TRUE
return #RESULT
;-----------------------------------------------------------------
sub TM_MoveSelectedItemUP
  namespace push
  namespace local TM_window_list_ , %1
  set !temp_LPC #LPC
  set #LPC 1000
  set !listname %1
  set !redraw %2
  set !highlight %3
  menu get !listname
  set #RESULT #FALSE
  if #MENURES > 1
  {
    set !prev_index #MENURES - 2
    set !curr_index #MENURES - 1
    set !temp_list !list . !prev_index
    set !temp_tag !tag . !prev_index
    set !list . !prev_index !list . !curr_index
    set !tag . !prev_index !tag . !curr_index
    set !list . !curr_index !temp_list
    set !tag . !curr_index !temp_tag
    if !redraw = #TRUE
      gosub TM_ReDrawList !listname
    if !highlight = #TRUE
      menu !listtype select !listname !curr_index
    set #RESULT #TRUE
  }
  set #LPC !temp_LPC
  namespace pop
  set !TM_FunctionCalled #TRUE
return #RESULT
;-----------------------------------------------------------------
sub TM_MoveSelectedItemDown
  namespace push
  namespace local TM_window_list_ , %1
  set !temp_LPC #LPC
  set #LPC 1000
  set !listname %1
  set !redraw %2
  set !highlight %3
  menu get !listname
  set #RESULT #FALSE
  if #MENURES < !list_ptr
  {
    set !prev_index #MENURES
    set !curr_index #MENURES - 1
    set !temp_list !list . !prev_index
    set !temp_tag !tag . !prev_index
    set !list . !prev_index !list . !curr_index
    set !tag . !prev_index !tag . !curr_index
    set !list . !curr_index !temp_list
    set !tag . !curr_index !temp_tag
    set !prev_index !prev_index + 1
    if !redraw = #TRUE
      gosub TM_ReDrawList !listname
    if !highlight = #TRUE
      menu !listtype select !listname !prev_index
    set #RESULT #TRUE
  }
  set #LPC !temp_LPC
  namespace pop
  set !TM_FunctionCalled #TRUE
return #RESULT
;-----------------------------------------------------------------
; #RESULT = #TRUE if successfully moved
sub TM_MoveIndexedItemUP
  namespace push
  namespace local TM_window_list_ , %1
  set !temp_LPC #LPC
  set #LPC 1000
  set !listname %1
  set !index %2
  set !redraw %3
  set !highlight %4
  menu get !listname
  set #RESULT #FALSE
  if !index > 0 && !index < !list_ptr
  {
    set !prev_index !index - 1
    set !curr_index !index
    set !temp_list !list . !prev_index
    set !temp_tag !tag . !prev_index
    set !list . !prev_index !list . !curr_index
    set !tag . !prev_index !tag . !curr_index
    set !list . !curr_index !temp_list
    set !tag . !curr_index !temp_tag
    if !redraw = #TRUE
      gosub TM_ReDrawList !listname
    if !highlight = #TRUE
      menu !listtype select !listname !curr_index
    set #RESULT #TRUE
  }
  set #LPC !temp_LPC
  namespace pop
  set !TM_FunctionCalled #TRUE
return #RESULT
;-----------------------------------------------------------------
; #RESULT = #TRUE if successfully moved
sub TM_MoveIndexedItemDown
  namespace push
  namespace local TM_window_list_ , %1
  set !temp_LPC #LPC
  set #LPC 1000
  set !listname %1
  set !index %2
  set !redraw %3
  set !highlight %4
  set #RESULT #FALSE
  if ( !index > 0 ) && ( !index < ( !list_ptr - 1 ) )
  {
    set !prev_index !index + 1
    set !curr_index !index
    set !temp_list !list . !prev_index
    set !temp_tag !tag . !prev_index
    set !list . !prev_index !list . !curr_index
    set !tag . !prev_index !tag . !curr_index
    set !list . !curr_index !temp_list
    set !tag . !curr_index !temp_tag
    set !prev_index !prev_index + 1
    if !redraw = #TRUE
      gosub TM_ReDrawList !listname
    if !highlight = #TRUE
      menu !listtype select !listname !prev_index
    set #RESULT #TRUE
  }
  set #LPC !temp_LPC
  namespace pop
  set !TM_FunctionCalled #TRUE
return #RESULT
;-----------------------------------------------------------------
sub TM_GetSelectedItem
  namespace push
  namespace local TM_window_list_ , %1
  set !temp_LPC #LPC
  set #LPC 1000
  set !listname %1
  menu get !listname
  if #MENURES <> 0
  {
    set #MENURES #MENURES - 1
    set #RESULT !list . #MENURES
  }
  else
  {
    set #RESULT #TRUE
  }
  set #LPC !temp_LPC
  namespace pop
  set !TM_FunctionCalled #TRUE
return #RESULT
;-----------------------------------------------------------------
sub TM_GetSelectedTag
  namespace push
  namespace local TM_window_list_ , %1
  set !temp_LPC #LPC
  set #LPC 1000
  set !listname %1
  menu get !listname
  if #MENURES <> 0
  {
    set #MENURES #MENURES - 1
    set #RESULT !tag . #MENURES
  }
  else
  {
    set #RESULT #TRUE
  }
  set #LPC !temp_LPC
  namespace pop
  set !TM_FunctionCalled #TRUE
return #RESULT
;-----------------------------------------------------------------
sub TM_AlphabetizeList
  namespace push
  namespace local TM_window_list_ , %1
  set !temp_LPC #LPC
  set !eval %2
  set #LPC 1000
  set !listname %1
  if !list_ptr < 2
    goto AlphabetizeList_skip
  set !end !list_ptr - 1
  for !i 0 !end
  {
    set !next !i + 1
    if !i = !end
      break
    for !j !next !end
    {
      set !iptr 0
      str len !list . !i
      set !ilen #STRRES
      set !jptr 0
      str len !list . !j
      set !jlen #STRRES
      set !len !ilen
      if !ilen > !jlen
         set !len !jlen
      for !p 1 !len
      {
        str mid !list . !i !p 1
        gosub TM_EvaluateCharacter #STRRES
        set !c1 #RESULT
        str mid !list . !j !p 1
        gosub TM_EvaluateCharacter #STRRES
        set !c2 #RESULT
        if !c1 = !c2
          continue
        if !c1 !eval !c2
        {
          set !temp !list . !i
          set !list . !i !list . !j
          set !list . !j !temp
          set !temp !tag . !i
          set !tag . !i !tag . !j
          set !tag . !j !temp
        }
        break
      }
    }
  }

AlphabetizeList_skip:
  set #LPC !temp_LPC
  namespace pop
  set !TM_FunctionCalled #TRUE
return #RESULT
;-----------------------------------------------------------------
sub TM_EvaluateCharacter
  namespace push
  namespace local EVAL
  set !char %1
  set !string ! , "#$%&'()*+,- , #DOT , /0123456789: , #SMC , <=>?@[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
  str pos !string !char
  namespace pop
  set !TM_FunctionCalled #TRUE
return #STRRES

;--------------------------------------------------------------------
;---------------------  Base User Functions -------------------------
;--------------------------------------------------------------------
; TM_NGFS_InitializeScript
; %1 - ScriptName
; %2 = (opt) generic : add this tag to create a generic (non-character relative data set)
sub TM_NGFS_InitializeScript
  namespace push
  namespace local TM_NGFS , _ , %1
  namespace clear
  set !lpc #LPC
  set #LPC 10000
  if %0 = 0
  {
    display ok You must name your script, spaces will be converted to underscores.
    stop
  }
  set !TM_FSSIZE 1000 ; do not change this!!
  set !script_name %1
  set !args %0
  gosub AddUnderscore !script_name
  set !script_name #RESULT
  if !args = 1
  {
    gosub AddUnderscore #SHARD
    set !slot #CHARID , _ , #RESULT , _ , !script_name , _vars
  }
  else
  {
    set !slot generic , _ , !script_name , _vars
  }
  set ! . !slot
  set !varcnt 0
  set !index 0
  set !script_index N/A
  while *TM_FS . !index <> N/A
  {
    if *TM_FS . !index = !slot
    {
      set !script_index !index
      break
    }
    set !index !index + 1
  }
  if !script_index = N/A
  {
    set !script_index !index
    set *TM_FS . !script_index !slot
  }
  set #LPC !lpc
  namespace pop
  set !TM_Function_found #TRUE
return
;--------------------------------------------------------------------
; TM_NGFS_RegisterVariables
; %1 - ScriptName
; %2 - NSType (local, global, std)  --> std is a %var
; %3 - NSName (std) --> std is a %var
; %4, %5, %6, etc. variable names (don't include the % or ! - so %var becomes var, etc)
sub TM_NGFS_RegisterVariables
  if %0 <= 3
  {
    display ok Not enough arguments
    stop
  }
  namespace push
  namespace local TM_NGFS , _ , %1
  if !slot = N/A
  {
    display ok You must name your script and also run TM_NGFS_InitializeScript first.
    stop
  }
  set !nstype %2
  set !nsname %3
  for !i 4 %0
  {
    set !var % . !i
    if !nstype ,  , !nsname ,  , !var notin ! . !slot
    {
      set !newval ! . !slot
      set ! . !slot !newval , !nstype ,  , !nsname ,  , !var , 
      set !varcnt !varcnt + 1
    }
  }
  namespace pop
  set !TM_Function_found #TRUE
return
;--------------------------------------------------------------------
; TM_NGFS_SaveVariables
; %1 - ScriptName
; assuming you have registered the variables, then everything will be saved in one call
sub TM_NGFS_SaveVariables
  if %0 = 0
  {
    display ok You must name your script, spaces will be converted to underscores.
    stop
  }
  namespace push
  namespace local TM_NGFS , _ , %1
  if !TM_FSSIZE = N/A
  {
    display ok You must first call TM_NGFS_InitializeScript and have$registered variables with TM_NGFS_RegisterVariables - STOPPING.
    stop
  }
  set !lpc #LPC
  set #LPC 10000
  set !outstring
  set !start 1
  set !sepcnt 1
  set !line_count 0
  set !temp_str ! . !slot

  for !i 1 !varcnt
  {
    gosub ReadItem ! . !slot
    set !nstype #RESULT
    gosub ReadItem ! . !slot
    set !nsname #RESULT
    gosub ReadItem ! . !slot
    set !var #RESULT
    if std in !nstype
    {
      set !val % . !var
    }
    else
    {
      namespace copy !var from !nstype !nsname
      set !val ! . !var
    }
    set !outstring !outstring , !nstype ,  , !nsname ,  , !var ,  , !val , 
    str len !outstring
    if #STRRES >= !TM_FSSIZE
    {
      set * . !slot , !line_count !outstring
      set !outstring
      set !line_count !line_count + 1
      set !start !start - 1
      str del ! . !slot 1 !start
      set ! . !slot #STRRES
      set !start 1
      set !sepcnt 1
    }
  }
  str len !outstring
  if #STRRES > 0
  {
    set * . !slot , !line_count !outstring
    set !line_count !line_count + 1
  }
  set * . !slot , !line_count N/A ; make sure there's nothing left at end of the list
  set #LPC !lpc
  set ! . !slot !temp_str
  namespace pop
  set !TM_Function_found #TRUE
return
;--------------------------------------------------------------------
; TM_NGFS_LoadVariables
; %1 - ScriptName
; note you have to call TM_NGFS_InitializeScript
sub TM_NGFS_LoadVariables
  if %0 = 0
  {
    display ok You must name your script, spaces will be converted to underscores.
    stop
  }
  namespace push
  namespace local TM_NGFS , _ , %1
  if !TM_FSSIZE = N/A
  {
    display ok You must first call TM_NGFS_InitializeScript - STOPPING.
    stop
  }
  set !lpc #LPC
  set #LPC 10000
  set !start 1
  set !sepcnt 1
  set !line_count 0
  set !temp !slot , !line_count
  set !string * . !temp
  set ! . !slot
  set !varcnt 0
  set !continue #TRUE
  while !continue = #TRUE
  {
    gosub ReadItem !string
    if !continue = #TRUE
    {
      set !nstype #RESULT
      gosub ReadItem !string
      set !nsname #RESULT
      gosub ReadItem !string
      set !var #RESULT
      gosub ReadItem !string
      set !val #RESULT
      if std in !nstype
      {
        set % . !var !val
      }
      else
      {
        set ! . !var !val
        namespace copy !var to !nstype !nsname
      }
      set !newval ! . !slot
      set ! . !slot !newval , !nstype ,  , !nsname ,  , !var , 
      set !varcnt !varcnt + 1
    }
    if !continue = #FALSE
    {
      set !line_count !line_count + 1
      set !temp !slot , !line_count
      set !string * . !temp
      set !start 1
      set !sepcnt 1
      if !string <> N/A
        set !continue #TRUE ; still more to process
    }
  }
  set #LPC !lpc
  namespace pop
  set !TM_Function_found #TRUE
return
;--------------------------------------------------------------------
; Used internally
sub ReadItem
  str pos %1  !sepcnt
  if #STRRES <> 0
  {
    set !len #STRRES - !start
    str mid %1 !start !len
    set !start !start + !len + 1
    set !sepcnt !sepcnt + 1
    return #STRRES
  }
  set !continue #FALSE
return #TRUE
;--------------------------------------------------------------------
; Used internally
; %1 - string to mung
sub AddUnderscore
  namespace push
  namespace local AU
  set !tempstring %1
  AddUnderscore_loop1:
    str pos !tempstring #SPC
    if #STRRES <> 0
    {
      set !val #STRRES - 1
      str left !tempstring !val
      set !left #STRRES
      set !val !val + 1
      str del !tempstring 1 !val
      set !tempstring !left , _ , #STRRES
      goto AddUnderscore_loop1
    }
  set #RESULT !tempstring
  namespace pop
return #RESULT
;--------- EasyUO Menu Designer Code Begin ---------
sub showEUOMenu1
	menu Clear
	menu Window Title TrailMyx's Drag(and Drop) Queen v11
	menu Window Color BtnFace
	menu Window Size 298 302
	menu Font Transparent #true
	menu Font Align Right
	menu Font Name MS Sans Serif
	menu Font Size 8
	menu Font Style 
	menu Font Color WindowText
	menu Font Transparent #false
	menu Font Align Left
	menu Text Ignore_Text 232 200 Ignore_Text_
	menu Text EUOLabel1 0 288 Status:
	menu Text EUOLabel2 212 8 <--- Keep
	menu Text EUOLabel3 208 100 <--- Ignore
	menu Button EUOButtonEnable 4 244 67 33 Disable
	menu Button EUOButtonDelete1 208 120 43 21 Delete
	menu Button EUOButtonClear1 208 144 43 21 Clear
	menu Font BGColor Window
	menu Edit EUOEditIgnore 0 196 221 221
	menu Font BGColor BtnFace
	menu Button EUOButtonDelete2 208 28 43 21 Delete
	menu Button EUOButtonClear2 208 52 43 21 Clear
	menu Font BGColor Window
	menu Edit EUOStatus 36 284 261 Ready , #spc , to , #spc , drag.
	menu Font BGColor BtnFace
	menu Check EUOCheckUseText 4 220 125 17 #true Use Ignore Text?
	menu Font BGColor Window
	menu Edit EUOEditMax 168 260 33 10
	menu Font BGColor BtnFace
	menu Check EUOCheckMax 204 260 85 17 #false Move Max?
	menu Check EUOCheckClosedContainer 132 220 153 17 #false Drop into closed container?
	menu Show 421 270
return
;--------- EasyUO Menu Designer Code End ---------
